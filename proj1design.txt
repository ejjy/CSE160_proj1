Design:

Most of my implementation for this project was done in the Node.nc file. This was primarily because I wanted to get the functionality down before I started optimizing and refactoring the code. If we look at the Node.nc code, there are a few major additions that I made to the skeleton code. The biggest modifications in the logic fall in the Receive event implementation where I added two more clauses, one for the flooding implementation and the other for neighbor discovery.

The main thing about flooding was to tell the nodes what to do in the event that they received a packet that was not meant for them. The idea is that if an intermediate node lying between the source and the destination nodes receives a message that's not directed to itself, it will rebroadcast this message using the broadcast channel. So the else statement does exactly that: if the destination of the packet is not the node's own ID, it will repackage the packet and decrease the TTL while keeping all the other information the same. It then sends the packet out on the broadcast channel, and the next node that hears the message will do the same if it is also not the destination node, thereby allowing us to do multi-hopping.

In addition to adding an else statement telling the node what to do when it receives a packet not meant for itself, I also modified the ping and ping reply statements. I changed the sendBuffer call to call Sender.send(sendPackage, AM_BROADCAST_ADDR). This ensured that the nodes would send their messages on the broadcast channel so that all available neighbors could hear it and pass it along. I realize that this is not the best way of doing this, as we would like to limit flooding the network as much as possible. This is something that I intend on fixing when I migrate my flooding implementation out to its own module and configuration.

There is one caveat to the flooding implementation, and that is the fact that we need to avoid indefinitely circulating packets. We prevent this on two fronts. The first method we use to avoid recirculating packets forever is to make use of the TTL (Time To Live) of the packet itself. Each packet will start out with a maximum lifespan on the network. With each hop the packet makes in the network, the node that rebroadcasts the message will decrement the TTL. This will keep happening until either the message is received by the intended destination node, or until the TTL reaches 0 and the packet is dropped. The other way we prevent indefinitely circulating packets is by implementing a list of packets that have been seen or sent by a node. This way if a message finds its way back to a node that has seen or sent it before, the node can simply drop the packet. 

In practice, this is quite simple: we simply do nothing with the packet when we receive it if the TTL is 0 or if we find the packet in our list of packets that have been seen or sent. In my code, I have a simple list of packets called PacketList as well as a function called findPack in Node.nc that simply looks up the packet in the list. Each time I see a new packet that is a ping or a ping reply, I simply push it into my list using a short function called pushPack. Same thing happens when I send a packet as well.

The messier part was neighbor discovery as it required a little bit more code to put in place. This required wiring a timer to my NodeC.nc so that I could use it in Node.nc. The main parts of the code for neighbor discovery were the periodic timer event, the receive logic, and the neighbor discovery itself. I configured the boot event to randomly start the node's periodic timer to fire at a random interval of 10 to 20 seconds. The periodic timer going off would trigger a fired event which then called another function that I created for the neighbor discovery itself.

The neighbor discovery concept I used was pretty simple. Each node would have a list of structs that contained a neighbor's node ID and its age. The concept of the node's age is how long does a node have to wait before it considers a neighbor dead and drops it from its list of neighbors. The way I designed the age to work is at the start of each neighbor discovery, if the list of neighbors is not empty, it will look through the list and increase the age of each neighbor by 1. This represents the number of neighbor discovery pings since they were last heard from. It also then looks through the list a second time to see if the age of any of the nodes is greater than 5 (an arbitrary number of pings, but I figured the firing time would amount to roughly a minute). If they were older than 5 pings, then they were dropped from the list. Then the node proceeds to put together a ping with the AM_BROADCAST_ADDR as the destination and sends it out on the broadcast channel.

In order to determine who's a neighbor and who's not, each node needs to be able to respond correctly to the packet type. I added an else if clause that looked for a packet with its destination set to AM_BROADCAST_ADDR. This identified neighbor discovery pings and could then let the node decide what to do from there. If it got a ping, then it simply packages a ping reply with its own id as the source and sends it back to the sender (it does NOT flood it). In turn, if the node receives a ping reply, that means that it has heard back from a neighbor and now has to decide what to do with this information. If the node finds the neighbor already in its neighbor list, then it updates the corresponding age of the neighbor to 0 and resets the counter. Otherwise, it's a new neighbor and needs to push it into the neighbor list.

There were some minor modifications I made throughout the code to enable sequence incrementing between different packets coming from the same node. Some new functions were also added to the list implementation to make the lists work. I also had to add the neighbor struct definition in the Node.nc code as well. All in all there were a lot of small things that I tweaked because I needed it to get some aspect of the functionality working correctly. If you ask me in person to explain it, I would be happy to.