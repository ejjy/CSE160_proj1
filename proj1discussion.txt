Discussion Questions

1. Event driven programming is nice because it allows you to define what counts as an event and how to respond accordingly to each event. This helps in designing the logic and functionality of your program. On the other hand, we do run into issues when multiple events start firing at the same time. It can end up breaking the program or just drowning out a response that should have taken place but did not.

2. The benefit of having both the TTL and the packet checking is that this provides us two ways of checking for packets that have been floating around for too long. The TTL decrements as the packet gets rebroadcast, causing the packet to be dropped when the TTL hits 0. Packet checking allows us to make sure that we're not rebroadcasting packets that we have already seen or sent before. This ensures that we cannot enter a loop in our network and circulate indefinitely.

If we only had flooding checks, our network may be expansive enough and well connected enough that there may be many many nodes that will be able to rebroadcast the message. The message may drift to a completely unrelated portion of the network and end up very far away from the destination. If we only have TTL, we will just end up passing the packets along until they die out. This isn't inherently a problem in indefinitely circulating packets, but rather a network congestion issue. Having one or the other is not enough to limit network congestion, so we need both in use together.

3. In a best case situation, all of our nodes are connected in a line. That is to say 1-2-3-4-5-....-n This limits how many packets will be recirculated because we don't have any loops and there are really only two directions that the packets can go in: forward and backward. The packets that go backward will be stopped with packet checking by the previous node, so they can really only go forward in the network. This way the nods will see the same packet at most two times (once when they first receive it and once when they see it again from the subsequent node) and only send it once.

In a worst case situation we have a network topology where every node is connected to every other node. In a network of n nodes, each node will have n-1 connections. In this case, we'll have major network congestion because each node will send the packet to n-1 nodes and will see it n-1 times. This would cause lots of collisions and lost packets in our network.

4. Instead of sending the packets out on the broadcast channel, the nodes can instead iterate through their neighbors and send the packets individually to each neighbor. This allows for staggering of the packets so as to avoid collisions on the network. It also helps in network congestion because the signal is not being broadcast to every node in the accessible region, and every node is also not using that broadcast channel all the time.

5. I thought the layout of the skeleton code was pretty well done as it was. The only thing I would have changed would be my own implementation of the two functionalities. I pushed most of my code into Node.nc because I was too busy worrying about getting it working first. I plan on going back and moving the neighbor discovery and flooding implementations into separate components and wiring them to the nodes instead once I get the chance.